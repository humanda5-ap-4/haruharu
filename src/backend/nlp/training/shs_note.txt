훌륭한 UX 아이디어예요! 👏
당신이 원하는 건:

✅ 챗봇 프론트엔드에서 사용자 메시지에 마우스를 올리면,
옆에 "학습데이터에 넣기" 버튼이 떠서 클릭 시 백엔드로 전송되어 저장되는 구조입니다.

🧩 구현 구성 요약
📍 프론트엔드 (React 또는 Vue 기반으로 설명)
사용자 메시지 컴포넌트에 hover 이벤트 추가

hover 시 버튼 UI 노출 (position: absolute)

버튼 클릭 시 POST /add-intent API 호출

📍 백엔드 (FastAPI 기준)
POST /add-intent endpoint 생성

text와 intent를 받아 intent_dataset.json에 추가

intent_embeddings.pkl 재생성 (선택)

function MessageBubble({ message, intent }) {
  const [hovered, setHovered] = useState(false);

  const handleAddToTraining = async () => {
    await fetch("/api/add-intent", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ text: message, intent }),
    });
    alert("🎉 학습 데이터에 추가 완료!");
  };

  return (
    <div
      className="relative group"
      onMouseEnter={() => setHovered(true)}
      onMouseLeave={() => setHovered(false)}
    >
      <div className="bg-gray-100 p-3 rounded-lg">{message}</div>

      {hovered && (
        <button
          className="absolute right-0 top-0 bg-blue-500 text-white text-xs p-1 rounded hover:bg-blue-600 transition"
          onClick={handleAddToTraining}
        >
          학습에 추가
        </button>
      )}
    </div>
  );
}

from fastapi import FastAPI, Request
from pydantic import BaseModel
import json, pickle
from sentence_transformers import SentenceTransformer
import torch

app = FastAPI()

DATASET_PATH = "dataset/intent_dataset.json"
EMBEDDING_PATH = "intent_embeddings.pkl"
SBERT_MODEL = "jhgan/ko-sbert-sts"
model = SentenceTransformer(SBERT_MODEL)

class AddIntent(BaseModel):
    text: str
    intent: str

@app.post("/add-intent")
async def add_intent(data: AddIntent):
    # 1. 데이터셋 추가
    with open(DATASET_PATH, "r", encoding="utf-8") as f:
        dataset = json.load(f)

    dataset.append({"text": data.text, "intent": data.intent})
    with open(DATASET_PATH, "w", encoding="utf-8") as f:
        json.dump(dataset, f, ensure_ascii=False, indent=2)

    # 2. 임베딩 갱신
    intent_texts = {}
    for item in dataset:
        intent_texts.setdefault(item["intent"], []).append(item["text"])

    intent_embeddings = {
        intent: model.encode(texts, convert_to_tensor=True).mean(dim=0, keepdim=True)
        for intent, texts in intent_texts.items()
    }

    with open(EMBEDDING_PATH, "wb") as f:
        pickle.dump(intent_embeddings, f)

    return {"message": "✅ 학습 데이터에 추가됨"}
